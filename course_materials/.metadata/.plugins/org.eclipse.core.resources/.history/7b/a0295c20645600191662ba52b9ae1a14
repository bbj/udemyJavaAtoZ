package com.udemy.app;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class App {

	/**
	 * Stream
	 **/

	public static void main(String[] args) {
		
		/**
		 * ez jó példa lesz. megmutatni, hogy a stream().filter-el vissza is lehet tölteni az elemeket és így
		 * létrehozni egy új listát (ami aztán értelemszerûen szabadon használható), vagy lehet direkt Stream-el
		 * "párosítani" a filterezést, de mivel a stream csak egyszer használható, nem tárol csak végrehajt, így ennek
		 * teljesen más a hasznosítási célja (új-szûrt lista tárolása VS csak megjelenítés, vagy átadás valaminek)
		 * megmutatni: ha duplikáljuk a filteredName-es forEach-et, akkor semmi gond, duplán íródik ki, ellenben
		 * ha duplikáljuk a str.forEach-et, akkor error "IllegalStateException: stream has already been operated upon
		 * or closed"
		 */
		List<String> names = Arrays.asList("Alan", "James", "Kevin", "Joe");
		List<String> filteredNames = names.stream().filter(name -> name.startsWith("J")).collect(Collectors.toList());
		names.forEach(n -> System.out.print(n + " "));
		System.out.println(""); //new line
		filteredNames.forEach(n -> System.out.print(n + " "));
		
		System.out.println("\n Stream example: ");
		Stream<String> str = names.stream().filter(name -> name.startsWith("J"));
		str.forEach(n -> System.out.print(n + " "));
		str.forEach(n -> System.out.print(n + " "));
		


	}

}
